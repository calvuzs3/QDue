package net.calvuz.qdue.quattrodue.utils;

import net.calvuz.qdue.quattrodue.models.HalfTeam;
import net.calvuz.qdue.quattrodue.models.Shift;
import net.calvuz.qdue.quattrodue.models.ShiftType;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

/**
 * Factory for creating shifts (Shift objects).
 * <p>
 * Updated to work with the new dynamic ShiftTypeFactory.
 * No longer relies on static workScheduleShift types but accesses the
 * dynamically configured workScheduleShift types from the factory cache.
 *
 * @author Updated 21/05/2025
 */
public final class ShiftFactory {

    private static final String TAG = ShiftFactory.class.getSimpleName();

    // Prevent instantiation
    private ShiftFactory() {}

    /**
     * Creates a workScheduleShift using a workScheduleShift type from the dynamic factory.
     *
     * @param shiftIndex Shift index (0-based) from ShiftTypeFactory
     * @param date Shift date
     * @return New Shift, or null if workScheduleShift type not found
     */
    public static Shift createShift(int shiftIndex, LocalDate date) {
        ShiftType workScheduleShift = ShiftTypeFactory.getShiftType(shiftIndex);

        if (workScheduleShift == null) {
            Log.w(TAG, "No workScheduleShift type found at index " + shiftIndex);
            return null;
        }

        return new Shift(workScheduleShift, date);
    }

    /**
     * Creates a workScheduleShift using a named workScheduleShift type from the dynamic factory.
     *
     * @param shiftName Name of the workScheduleShift type
     * @param date Shift date
     * @return New Shift, or null if workScheduleShift type not found
     */
    public static Shift createShift(String shiftName, LocalDate date) {
        ShiftType workScheduleShift = ShiftTypeFactory.getShiftType(shiftName);

        if (workScheduleShift == null) {
            Log.w(TAG, "No workScheduleShift type found with name: " + shiftName);
            return null;
        }

        return new Shift(workScheduleShift, date);
    }

    /**
     * Creates a standard workScheduleShift by legacy index (for backward compatibility).
     *
     * @deprecated Use createShift(int, LocalDate) instead
     * @param type Legacy workScheduleShift type (1=first, 2=second, 3=third workScheduleShift)
     * @param date Shift date
     * @return New Shift
     * @throws IllegalArgumentException if workScheduleShift type is invalid or not available
     */
    @Deprecated
    public static Shift createStandardShift(int type, LocalDate date) {
        if (type < 1) {
            throw new IllegalArgumentException("Shift type must be >= 1, got: " + type);
        }

        // Convert 1-based to 0-based index
        int shiftIndex = type - 1;
        int availableShifts = ShiftTypeFactory.getShiftCount();

        if (shiftIndex >= availableShifts) {
            throw new IllegalArgumentException(
                    "Shift type " + type + " not available. Only " + availableShifts + " shifts configured."
            );
        }

        Shift workScheduleShift = createShift(shiftIndex, date);
        if (workScheduleShift == null) {
            throw new IllegalArgumentException("Failed to create workScheduleShift for type: " + type);
        }

        return workScheduleShift;
    }

    /**
     * Creates all configured shifts for a specific date.
     * Uses all workScheduleShift types available in the ShiftTypeFactory.
     *
     * @param date Date for the shifts
     * @return List of shifts (size depends on factory configuration)
     */
    public static List<Shift> createDailyShifts(LocalDate date) {
        int shiftCount = ShiftTypeFactory.getShiftCount();
        List<Shift> shifts = new ArrayList<>(shiftCount);

        for (int i = 0; i < shiftCount; i++) {
            Shift workScheduleShift = createShift(i, date);
            if (workScheduleShift != null) {
                shifts.add(workScheduleShift);
            } else {
                Log.w(TAG, "Skipped null workScheduleShift at index " + i + " for date " + date);
            }
        }

        if (shifts.isEmpty()) {
            Log.e(TAG, "No shifts created for date " + date + ". ShiftTypeFactory not initialized?");
        }

        return shifts;
    }

    /**
     * Creates all shifts with specific names for a date.
     *
     * @param date Date for the shifts
     * @param shiftNames Array of workScheduleShift names to create
     * @return List of created shifts (may be smaller than input if some names not found)
     */
    public static List<Shift> createNamedShifts(LocalDate date, String... shiftNames) {
        List<Shift> shifts = new ArrayList<>(shiftNames.length);

        for (String shiftName : shiftNames) {
            Shift workScheduleShift = createShift(shiftName, date);
            if (workScheduleShift != null) {
                shifts.add(workScheduleShift);
            } else {
                Log.w(TAG, "Shift not found: " + shiftName);
            }
        }

        return shifts;
    }

    /**
     * Creates a custom workScheduleShift with specified parameters.
     *
     * @param workScheduleShift Type of workScheduleShift (from ShiftTypeFactory or custom)
     * @param date Shift date
     * @param isStop Indicates if workScheduleShift is during plant stop
     * @param teams Teams assigned to the workScheduleShift
     * @return New Shift
     */
    public static Shift createCustomShift(ShiftType workScheduleShift, LocalDate date,
                                          boolean isStop, List<HalfTeam> teams) {
        if (workScheduleShift == null) {
            Log.e(TAG, "Cannot create workScheduleShift with null ShiftType");
            return null;
        }

        Shift workScheduleShift = new Shift(workScheduleShift, date);
        workScheduleShift.setStop(isStop);

        if (teams != null) {
            for (HalfTeam team : teams) {
                workScheduleShift.addHalfTeam(team);
            }
        }

        return workScheduleShift;
    }

    /**
     * Creates a custom workScheduleShift with teams, using a workScheduleShift type from the factory.
     *
     * @param shiftIndex Index of workScheduleShift type in factory
     * @param date Shift date
     * @param isStop Indicates if workScheduleShift is during plant stop
     * @param teams Teams assigned to the workScheduleShift
     * @return New Shift, or null if workScheduleShift type not found
     */
    public static Shift createCustomShift(int shiftIndex, LocalDate date,
                                          boolean isStop, List<HalfTeam> teams) {
        ShiftType workScheduleShift = ShiftTypeFactory.getShiftType(shiftIndex);
        return createCustomShift(workScheduleShift, date, isStop, teams);
    }

    /**
     * Creates a custom workScheduleShift with teams, using a named workScheduleShift type from the factory.
     *
     * @param shiftName Name of workScheduleShift type in factory
     * @param date Shift date
     * @param isStop Indicates if workScheduleShift is during plant stop
     * @param teams Teams assigned to the workScheduleShift
     * @return New Shift, or null if workScheduleShift type not found
     */
    public static Shift createCustomShift(String shiftName, LocalDate date,
                                          boolean isStop, List<HalfTeam> teams) {
        ShiftType workScheduleShift = ShiftTypeFactory.getShiftType(shiftName);
        return createCustomShift(workScheduleShift, date, isStop, teams);
    }

    /**
     * Utility method to check if ShiftTypeFactory is properly initialized.
     *
     * @return true if factory is ready to use
     */
    public static boolean isFactoryReady() {
        return ShiftTypeFactory.isInitialized() && ShiftTypeFactory.getShiftCount() > 0;
    }

    /**
     * Gets information about available workScheduleShift types for debugging.
     *
     * @return String with workScheduleShift type information
     */
    public static String getAvailableShiftsInfo() {
        if (!isFactoryReady()) {
            return "ShiftTypeFactory not initialized";
        }

        StringBuilder info = new StringBuilder();
        info.append("Available shifts (").append(ShiftTypeFactory.getShiftCount()).append("):\n");

        List<ShiftType> shiftTypes = ShiftTypeFactory.getAllShiftTypes();
        for (int i = 0; i < shiftTypes.size(); i++) {
            ShiftType workScheduleShift = shiftTypes.get(i);
            info.append("  [").append(i).append("] ")
                    .append(workScheduleShift.getName())
                    .append(" (").append(workScheduleShift.getFormattedStartTime())
                    .append("-").append(workScheduleShift.getFormattedEndTime()).append(")\n");
        }

        return info.toString();
    }

    /**
     * Builder pattern for creating shifts with fluent interface.
     */
    public static class Builder {
        private int shiftIndex = -1;
        private String shiftName;
        private ShiftType customShiftType;
        private LocalDate date;
        private boolean isStop = false;
        private List<HalfTeam> teams = new ArrayList<>();

        /**
         * Sets workScheduleShift type by factory index.
         */
        public Builder withShiftIndex(int index) {
            this.shiftIndex = index;
            this.shiftName = null;
            this.customShiftType = null;
            return this;
        }

        /**
         * Sets workScheduleShift type by name from factory.
         */
        public Builder withShiftName(String name) {
            this.shiftName = name;
            this.shiftIndex = -1;
            this.customShiftType = null;
            return this;
        }

        /**
         * Sets custom workScheduleShift type (not from factory).
         */
        public Builder withCustomShiftType(ShiftType workScheduleShift) {
            this.customShiftType = workScheduleShift;
            this.shiftIndex = -1;
            this.shiftName = null;
            return this;
        }

        /**
         * Sets the workScheduleShift date.
         */
        public Builder forDate(LocalDate date) {
            this.date = date;
            return this;
        }

        /**
         * Marks the workScheduleShift as during plant stop.
         */
        public Builder asStop() {
            this.isStop = true;
            return this;
        }

        /**
         * Adds a team to the workScheduleShift.
         */
        public Builder addTeam(HalfTeam team) {
            if (team != null) {
                this.teams.add(team);
            }
            return this;
        }

        /**
         * Adds multiple teams to the workScheduleShift.
         */
        public Builder addTeams(List<HalfTeam> teams) {
            if (teams != null) {
                this.teams.addAll(teams);
            }
            return this;
        }

        /**
         * Builds the workScheduleShift with configured parameters.
         *
         * @return Created Shift, or null if configuration is invalid
         */
        public Shift build() {
            if (date == null) {
                Log.e(TAG, "Cannot build workScheduleShift without date");
                return null;
            }

            ShiftType workScheduleShift = null;

            // Determine workScheduleShift type from configuration
            if (customShiftType != null) {
                workScheduleShift = customShiftType;
            } else if (shiftName != null) {
                workScheduleShift = ShiftTypeFactory.getShiftType(shiftName);
            } else if (shiftIndex >= 0) {
                workScheduleShift = ShiftTypeFactory.getShiftType(shiftIndex);
            }

            if (workScheduleShift == null) {
                Log.e(TAG, "Cannot determine workScheduleShift type for builder");
                return null;
            }

            return createCustomShift(workScheduleShift, date, isStop, teams);
        }
    }
}
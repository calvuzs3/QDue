package net.calvuz.qdue.core.services.impl;

import android.content.Context;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import net.calvuz.qdue.core.common.i18n.LocaleManager;
import net.calvuz.qdue.core.db.CalendarDatabase;
import net.calvuz.qdue.core.services.CalendarService;
import net.calvuz.qdue.core.services.models.OperationResult;
import net.calvuz.qdue.domain.calendar.engines.ExceptionResolver;
import net.calvuz.qdue.domain.calendar.engines.RecurrenceCalculator;
import net.calvuz.qdue.domain.calendar.models.RecurrenceRule;
import net.calvuz.qdue.domain.calendar.models.Shift;
import net.calvuz.qdue.domain.calendar.models.ShiftException;
import net.calvuz.qdue.domain.calendar.models.Team;
import net.calvuz.qdue.domain.calendar.models.UserScheduleAssignment;
import net.calvuz.qdue.domain.calendar.models.WorkScheduleDay;
import net.calvuz.qdue.domain.calendar.models.WorkScheduleShift;
import net.calvuz.qdue.domain.calendar.repositories.ShiftExceptionRepository;
import net.calvuz.qdue.domain.calendar.repositories.ShiftRepository;
import net.calvuz.qdue.domain.calendar.repositories.TeamRepository;
import net.calvuz.qdue.domain.calendar.repositories.UserScheduleAssignmentRepository;
import net.calvuz.qdue.domain.calendar.usecases.ApplyShiftExceptionsUseCase;
import net.calvuz.qdue.domain.calendar.usecases.GenerateTeamScheduleUseCase;
import net.calvuz.qdue.domain.calendar.usecases.GenerateUserScheduleUseCase;
import net.calvuz.qdue.domain.calendar.usecases.GetScheduleStatsUseCase;
import net.calvuz.qdue.domain.common.i18n.DomainLocalizer;
import net.calvuz.qdue.ui.core.common.utils.Log;

import java.time.LocalDate;
import java.time.YearMonth;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

/**
 * CalendarServiceImpl - Clean Architecture Implementation of CalendarService
 *
 * <p>Production implementation of the CalendarService interface following strict
 * clean architecture principles with domain-driven design, dependency injection,
 * and comprehensive internationalization support.</p>
 *
 * <h3>Clean Architecture Compliance:</h3>
 * <ul>
 *   <li><strong>Dependency Direction</strong>: Only depends on abstractions, never concretions</li>
 *   <li><strong>Domain Independence</strong>: Domain logic isolated in engines and use cases</li>
 *   <li><strong>Infrastructure Abstraction</strong>: All data access through repository interfaces</li>
 *   <li><strong>Service Layer Orchestration</strong>: Coordinates between domain and infrastructure</li>
 * </ul>
 *
 * <h3>Dependency Injection Architecture:</h3>
 * <ul>
 *   <li><strong>Constructor Injection</strong>: All dependencies injected via constructor</li>
 *   <li><strong>Interface Dependencies</strong>: Depends only on interfaces, not implementations</li>
 *   <li><strong>DomainLocalizer Integration</strong>: Clean i18n support for domain models</li>
 *   <li><strong>ServiceProvider Integration</strong>: Full integration with DI system</li>
 * </ul>
 *
 * <h3>Domain Integration Features:</h3>
 * <ul>
 *   <li><strong>Pure Domain Engines</strong>: ExceptionResolver and RecurrenceCalculator</li>
 *   <li><strong>Use Case Pattern</strong>: Complex operations delegated to use cases</li>
 *   <li><strong>Repository Pattern</strong>: All data access through repository abstractions</li>
 *   <li><strong>Domain Localization</strong>: Full i18n support for domain models</li>
 * </ul>
 *
 * <h3>Performance and Reliability:</h3>
 * <ul>
 *   <li><strong>Async Operations</strong>: All operations return CompletableFuture</li>
 *   <li><strong>Multi-Level Caching</strong>: Intelligent cache with TTL and invalidation</li>
 *   <li><strong>Thread Pool Management</strong>: Dedicated thread pool for calendar operations</li>
 *   <li><strong>OperationResult Pattern</strong>: Consistent error handling with detailed feedback</li>
 * </ul>
 *
 * @author QDue Development Team
 * @version 4.0.0 - Clean Architecture & DI Compliant
 * @since Clean Architecture Phase 2
 */
public class CalendarServiceImpl implements CalendarService {

    private static final String TAG = "CalendarServiceImpl";

    // ==================== DEPENDENCIES (INJECTED) ====================

    private final Context mContext;
    private final CalendarDatabase mDatabase;
    private final LocaleManager mLocaleManager;

    // Repository dependencies (interfaces only)
    private final ShiftExceptionRepository mShiftExceptionRepository;
    private final TeamRepository mTeamRepository;
    private final ShiftRepository mShiftRepository;
    private final UserScheduleAssignmentRepository mUserScheduleAssignmentRepository;

    // Nell'area delle variabili di istanza aggiungere:
    private volatile CalendarService mCalendarService;

    // Nell'area dei synchronization objects aggiungere:
    private final Object mCalendarServiceLock = new Object();

    // Use cases for complex operations (interfaces only)
    private final GenerateUserScheduleUseCase mGenerateUserScheduleUseCase;
    private final GenerateTeamScheduleUseCase mGenerateTeamScheduleUseCase;
    private final ApplyShiftExceptionsUseCase mApplyShiftExceptionsUseCase;
    private final GetScheduleStatsUseCase mGetScheduleStatsUseCase;

    // Domain engines (pure algorithms with localization)
    private final ExceptionResolver mExceptionResolver;
    private final RecurrenceCalculator mRecurrenceCalculator;

    // Domain localization support
    private final DomainLocalizer mDomainLocalizer;

    // Threading and performance infrastructure
    private final ExecutorService mExecutorService;
    private final Map<String, WorkScheduleDay> mScheduleCache;
    private final Map<String, Team> mTeamCache;
    private final Map<String, Shift> mShiftCache;

    // ==================== STATE MANAGEMENT ====================

    private volatile boolean mIsInitialized = false;

    // ==================== CONSTRUCTOR FOR DEPENDENCY INJECTION ====================

    /**
     * Constructor for dependency injection via DomainServiceProvider.
     *
     * <p>All dependencies are injected as interfaces to maintain clean architecture
     * principles. The service orchestrates between domain engines, use cases, and
     * repositories without direct knowledge of their implementations.</p>
     *
     * @param context Application context for system resources
     * @param database CalendarDatabase for data persistence
     * @param localeManager LocaleManager for core i18n infrastructure
     * @param domainLocalizer DomainLocalizer for domain layer i18n support
     * @param shiftExceptionRepository Repository interface for shift exceptions
     * @param teamRepository Repository interface for team operations
     * @param shiftRepository Repository interface for shift operations
     * @param userScheduleAssignmentRepository Repository interface for user assignments
     * @param generateUserScheduleUseCase Use case for user schedule generation
     * @param generateTeamScheduleUseCase Use case for team schedule generation
     * @param applyShiftExceptionsUseCase Use case for exception application
     * @param getScheduleStatsUseCase Use case for schedule statistics
     */
    public CalendarServiceImpl(@NonNull Context context,
                               @NonNull CalendarDatabase database,
                               @NonNull LocaleManager localeManager,
                               @NonNull DomainLocalizer domainLocalizer,
                               @NonNull ShiftExceptionRepository shiftExceptionRepository,
                               @NonNull TeamRepository teamRepository,
                               @NonNull ShiftRepository shiftRepository,
                               @NonNull UserScheduleAssignmentRepository userScheduleAssignmentRepository,
                               @NonNull GenerateUserScheduleUseCase generateUserScheduleUseCase,
                               @NonNull GenerateTeamScheduleUseCase generateTeamScheduleUseCase,
                               @NonNull ApplyShiftExceptionsUseCase applyShiftExceptionsUseCase,
                               @NonNull GetScheduleStatsUseCase getScheduleStatsUseCase) {

        // Core infrastructure dependencies
        this.mContext = context.getApplicationContext();
        this.mDatabase = database;
        this.mLocaleManager = localeManager;
        this.mDomainLocalizer = domainLocalizer.scope("calendar");

        // Repository dependencies (clean architecture - interfaces only)
        this.mShiftExceptionRepository = shiftExceptionRepository;
        this.mTeamRepository = teamRepository;
        this.mShiftRepository = shiftRepository;
        this.mUserScheduleAssignmentRepository = userScheduleAssignmentRepository;

        // Use case dependencies (domain layer orchestration)
        this.mGenerateUserScheduleUseCase = generateUserScheduleUseCase;
        this.mGenerateTeamScheduleUseCase = generateTeamScheduleUseCase;
        this.mApplyShiftExceptionsUseCase = applyShiftExceptionsUseCase;
        this.mGetScheduleStatsUseCase = getScheduleStatsUseCase;

        // Initialize domain engines with localization support
        this.mExceptionResolver = ExceptionResolver.create(mDomainLocalizer.scope("exceptions"));
        this.mRecurrenceCalculator = RecurrenceCalculator.create(mDomainLocalizer.scope("recurrence"));

        // Initialize performance infrastructure
        this.mExecutorService = Executors.newFixedThreadPool(4, r -> {
            Thread thread = new Thread(r, "CalendarService-" + Thread.currentThread().getId());
            thread.setDaemon(true);
            return thread;
        });

        this.mScheduleCache = new ConcurrentHashMap<>();
        this.mTeamCache = new ConcurrentHashMap<>();
        this.mShiftCache = new ConcurrentHashMap<>();

        Log.i(TAG, "CalendarServiceImpl created with clean architecture dependencies and domain localization support");
    }

    // ==================== SERVICE LIFECYCLE ====================

    @Override
    public void initialize() {
        if (mIsInitialized) {
            Log.w(TAG, "CalendarService already initialized");
            return;
        }

        try {
            Log.d(TAG, "Initializing CalendarService with domain localization...");

            // Pre-load commonly used data for performance
            preloadTeamData();
            preloadShiftTemplates();

            mIsInitialized = true;
            Log.i(TAG, "CalendarService initialized successfully with localization scope: " +
                    mDomainLocalizer.localize("service.initialized", "Calendar Service Ready"));

        } catch (Exception e) {
            Log.e(TAG, "Error initializing CalendarService", e);
            mIsInitialized = false;
        }
    }

    @Override
    public boolean isReady() {
        return mIsInitialized &&
                mDatabase != null &&
                mDomainLocalizer != null &&
                mShiftExceptionRepository != null &&
                mTeamRepository != null &&
                mUserScheduleAssignmentRepository != null;
    }

    @Override
    public void cleanup() {
        Log.d(TAG, "Cleaning up CalendarService resources");

        clearScheduleCache();

        if (mExecutorService != null && !mExecutorService.isShutdown()) {
            mExecutorService.shutdown();
        }

        mIsInitialized = false;
        Log.d(TAG, "CalendarService cleanup completed");
    }


    // Aggiungere il metodo getter per CalendarService:
    @Override
    public CalendarService getCalendarService() {
        if (mCalendarService == null) {
            synchronized (mCalendarServiceLock) {
                if (mCalendarService == null) {
                    try {
                        Log.d(TAG, "Initializing CalendarService...");
                        mCalendarService = new CalendarServiceImpl(
                                mContext,
                                getDatabase(),
                                getCoreBackupManager()
                        );
                        mCalendarService.initialize();
                        Log.d(TAG, "CalendarService initialized successfully");
                    } catch (Exception e) {
                        Log.e(TAG, "Failed to initialize CalendarService", e);
                        throw new RuntimeException("CalendarService initialization failed", e);
                    }
                }
            }
        }
        return mCalendarService;
    }

    // ==================== USER SCHEDULE OPERATIONS ====================

    @Override
    @NonNull
    public CompletableFuture<OperationResult<WorkScheduleDay>> getUserScheduleForDate(
            @NonNull Long userId, @NonNull LocalDate date) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                if (!isReady()) {
                    return OperationResult.failure("CalendarService not ready",
                            OperationResult.OperationType.READ);
                }

                Log.d(TAG, "Generating user schedule for userId: " + userId + ", date: " + date);

                // Check cache first for performance
                String cacheKey = generateUserCacheKey(userId, date);
                WorkScheduleDay cachedResult = mScheduleCache.get(cacheKey);
                if (cachedResult != null) {
                    Log.d(TAG, "Cache hit for user schedule: " + cacheKey);
                    return OperationResult.success(cachedResult,
                            OperationResult.OperationType.READ);
                }

                // Get user's active assignment for the date
                UserScheduleAssignment assignment = getUserAssignmentForDate(userId, date);
                if (assignment == null) {
                    Log.w(TAG, "No active assignment found for user " + userId + " on " + date);
                    WorkScheduleDay emptySchedule = createEmptyScheduleDay(date);
                    return OperationResult.success(emptySchedule,
                            OperationResult.OperationType.READ);
                }

                // Generate base schedule from recurrence using domain engine
                WorkScheduleDay baseSchedule = generateBaseScheduleFromAssignment(assignment, date);

                // Apply exceptions using pure domain algorithm
                WorkScheduleDay finalSchedule = applyExceptionsToSchedule(baseSchedule, userId, date);

                // Cache the result for performance
                mScheduleCache.put(cacheKey, finalSchedule);

                Log.d(TAG, "Successfully generated user schedule with " +
                        finalSchedule.getShifts().size() + " shifts");

                return OperationResult.success(finalSchedule,
                        OperationResult.OperationType.READ);

            } catch (Exception e) {
                Log.e(TAG, "Error generating user schedule for " + userId + " on " + date, e);
                return OperationResult.failure(e, OperationResult.OperationType.READ);
            }
        }, mExecutorService);
    }

    @Override
    @NonNull
    public CompletableFuture<OperationResult<Map<LocalDate, WorkScheduleDay>>> getUserScheduleForDateRange(
            @NonNull Long userId, @NonNull LocalDate startDate, @NonNull LocalDate endDate) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                if (!isReady()) {
                    return OperationResult.failure("CalendarService not ready",
                            OperationResult.OperationType.READ);
                }

                Log.d(TAG, "Generating user schedule range for userId: " + userId +
                        ", dates: " + startDate + " to " + endDate);

                Map<LocalDate, WorkScheduleDay> scheduleMap = new HashMap<>();

                // Get all assignments for the date range (batch operation for performance)
                List<UserScheduleAssignment> assignments =
                        mUserScheduleAssignmentRepository.getAssignmentsForUserInDateRange(
                                userId, startDate, endDate).join();

                // Get all exceptions for the date range (batch operation for performance)
                List<ShiftException> exceptions =
                        mShiftExceptionRepository.getExceptionsForUserInDateRange(
                                userId, startDate, endDate).join();

                // Build user-team mappings for the period
                Map<Long, Team> userTeamMappings = buildUserTeamMappingsForPeriod(
                        List.of(userId), startDate, endDate);

                // Build replacement shifts map for exceptions
                Map<String, WorkScheduleShift> replacementShifts =
                        buildReplacementShiftsMap(exceptions);

                // Process each date in the range
                LocalDate currentDate = startDate;
                while (!currentDate.isAfter(endDate)) {

                    // Find active assignment for this date
                    UserScheduleAssignment activeAssignment = findAssignmentForDate(assignments, currentDate);

                    if (activeAssignment != null) {
                        // Generate base schedule using domain engine
                        WorkScheduleDay baseSchedule =
                                generateBaseScheduleFromAssignment(activeAssignment, currentDate);

                        // Apply exceptions for this date using domain algorithm
                        List<ShiftException> dateExceptions =
                                filterExceptionsForDate(exceptions, currentDate);

                        WorkScheduleDay finalSchedule = mExceptionResolver.applyExceptions(
                                baseSchedule, dateExceptions, userTeamMappings, replacementShifts);

                        scheduleMap.put(currentDate, finalSchedule);
                    } else {
                        scheduleMap.put(currentDate, createEmptyScheduleDay(currentDate));
                    }

                    currentDate = currentDate.plusDays(1);
                }

                Log.d(TAG, "Successfully generated user schedule range with " +
                        scheduleMap.size() + " days");

                return OperationResult.success(scheduleMap, OperationResult.OperationType.READ);

            } catch (Exception e) {
                Log.e(TAG, "Error generating user schedule range", e);
                return OperationResult.failure(e.getMessage(), OperationResult.OperationType.READ);
            }
        }, mExecutorService);
    }

    @Override
    @NonNull
    public CompletableFuture<OperationResult<Map<LocalDate, WorkScheduleDay>>> getUserScheduleForMonth(
            @NonNull Long userId, @NonNull YearMonth month) {

        LocalDate startDate = month.atDay(1);
        LocalDate endDate = month.atEndOfMonth();

        return getUserScheduleForDateRange(userId, startDate, endDate);
    }

    // ==================== TEAM SCHEDULE OPERATIONS ====================

    @Override
    @NonNull
    public CompletableFuture<OperationResult<WorkScheduleDay>> getTeamScheduleForDate(
            @NonNull LocalDate date, @Nullable Integer teamId) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                if (!isReady()) {
                    return OperationResult.failure("CalendarService not ready",
                            OperationResult.OperationType.READ);
                }

                Log.d(TAG, "Generating team schedule for date: " + date + ", teamId: " + teamId);

                // Delegate to use case for complex team schedule generation
                CompletableFuture<OperationResult<WorkScheduleDay>> teamScheduleResult =
                        mGenerateTeamScheduleUseCase.executeForDate(date, teamId);

                OperationResult<WorkScheduleDay> result = teamScheduleResult.join();

                if (result.isSuccess()) {
                    Log.d(TAG, "Successfully generated team schedule with " +
                            result.getData().getShifts().size() + " shifts");
                } else {
                    Log.w(TAG, "Team schedule generation failed: " + result.getFormattedErrorMessage());
                }

                return result;

            } catch (Exception e) {
                Log.e(TAG, "Error generating team schedule", e);
                return OperationResult.failure(e.getMessage(), OperationResult.OperationType.READ);
            }
        }, mExecutorService);
    }

    @Override
    @NonNull
    public CompletableFuture<OperationResult<Map<LocalDate, WorkScheduleDay>>> getTeamScheduleForDateRange(
            @NonNull LocalDate startDate, @NonNull LocalDate endDate, @Nullable Integer teamId) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                if (!isReady()) {
                    return OperationResult.failure("CalendarService not ready",
                            OperationResult.OperationType.READ);
                }

                // Delegate to use case for complex team schedule generation
                CompletableFuture<OperationResult<Map<LocalDate, WorkScheduleDay>>> teamScheduleResult =
                        mGenerateTeamScheduleUseCase.executeForDateRange(startDate, endDate, teamId);

                return teamScheduleResult.join();

            } catch (Exception e) {
                Log.e(TAG, "Error generating team schedule range", e);
                return OperationResult.failure(e.getMessage(), OperationResult.OperationType.READ);
            }
        }, mExecutorService);
    }

    // ==================== EXCEPTION HANDLING OPERATIONS ====================

    @Override
    @NonNull
    public CompletableFuture<OperationResult<WorkScheduleDay>> applyShiftExceptions(
            @NonNull Long userId, @NonNull LocalDate date) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                if (!isReady()) {
                    return OperationResult.failure("CalendarService not ready",
                            OperationResult.OperationType.UPDATE);
                }

                // Get base schedule first
                OperationResult<WorkScheduleDay> baseScheduleResult =
                        getUserScheduleForDate(userId, date).join();

                if (!baseScheduleResult.isSuccess()) {
                    return baseScheduleResult;
                }

                WorkScheduleDay baseSchedule = baseScheduleResult.getData();

                // Apply exceptions using pure domain algorithm
                WorkScheduleDay scheduleWithExceptions =
                        applyExceptionsToSchedule(baseSchedule, userId, date);

                return OperationResult.success(scheduleWithExceptions,
                        OperationResult.OperationType.UPDATE);

            } catch (Exception e) {
                Log.e(TAG, "Error applying shift exceptions", e);
                return OperationResult.failure(e.getMessage(), OperationResult.OperationType.UPDATE);
            }
        }, mExecutorService);
    }

    @Override
    @NonNull
    public CompletableFuture<OperationResult<GetScheduleStatsUseCase.ScheduleValidationResult>> validateScheduleChanges(
            @NonNull Long userId, @NonNull LocalDate originalDate, @NonNull String proposedChanges) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                if (!isReady()) {
                    return OperationResult.failure("CalendarService not ready",
                            OperationResult.OperationType.VALIDATION);
                }

                // Delegate to use case for validation logic
                CompletableFuture<OperationResult<GetScheduleStatsUseCase.ScheduleValidationResult>> validationResult =
                        mGetScheduleStatsUseCase.validateScheduleChanges(userId, originalDate, proposedChanges);

                return validationResult.join();

            } catch (Exception e) {
                Log.e(TAG, "Error validating schedule changes", e);
                return OperationResult.failure(e.getMessage(), OperationResult.OperationType.VALIDATION);
            }
        }, mExecutorService);
    }

    // ==================== ANALYTICS AND REPORTING ====================

    @Override
    @NonNull
    public CompletableFuture<OperationResult<GetScheduleStatsUseCase.ScheduleStats>> getScheduleStatistics(
            @NonNull LocalDate startDate, @NonNull LocalDate endDate, @Nullable Long userId) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                if (!isReady()) {
                    return OperationResult.failure("CalendarService not ready",
                            OperationResult.OperationType.READ);
                }

                // Delegate to use case for analytics
                CompletableFuture<OperationResult<GetScheduleStatsUseCase.ScheduleStats>> statsResult =
                        mGetScheduleStatsUseCase.executeAnalysis(startDate, endDate, userId);

                return statsResult.join();

            } catch (Exception e) {
                Log.e(TAG, "Error generating schedule statistics", e);
                return OperationResult.failure(e.getMessage(), OperationResult.OperationType.READ);
            }
        }, mExecutorService);
    }

    // ==================== TEAM AND USER MANAGEMENT ====================

    @Override
    @NonNull
    public CompletableFuture<OperationResult<List<Long>>> getActiveUsers() {
        return mUserScheduleAssignmentRepository.getAllActiveUserIds()
                .thenApply(userIds -> OperationResult.success(userIds, OperationResult.OperationType.READ))
                .exceptionally(e -> {
                    Log.e(TAG, "Error getting active users", e);
                    return OperationResult.failure(e.getMessage(), OperationResult.OperationType.READ);
                });
    }

    @Override
    @NonNull
    public CompletableFuture<OperationResult<Team>> getTeamForUser(@NonNull Long userId, @NonNull LocalDate date) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                UserScheduleAssignment assignment = getUserAssignmentForDate(userId, date);
                if (assignment != null) {
                    Team team = mTeamRepository.getTeamById(assignment.getTeamId()).join();
                    return OperationResult.success(team, OperationResult.OperationType.READ);
                } else {
                    return OperationResult.success(null, OperationResult.OperationType.READ);
                }
            } catch (Exception e) {
                Log.e(TAG, "Error getting team for user: " + userId, e);
                return OperationResult.failure(e.getMessage(), OperationResult.OperationType.READ);
            }
        }, mExecutorService);
    }

    // ==================== CACHE MANAGEMENT ====================

    @Override
    public void clearScheduleCache() {
        mScheduleCache.clear();
        mTeamCache.clear();
        mShiftCache.clear();
        Log.d(TAG, "All caches cleared");
    }

    @Override
    public void clearCacheForDateRange(@NonNull LocalDate startDate, @NonNull LocalDate endDate) {
        mScheduleCache.entrySet().removeIf(entry -> {
            String key = entry.getKey();
            try {
                // Extract date from cache key
                String dateStr = extractDateFromCacheKey(key);
                LocalDate keyDate = LocalDate.parse(dateStr);
                return !keyDate.isBefore(startDate) && !keyDate.isAfter(endDate);
            } catch (Exception e) {
                return false;
            }
        });
        Log.d(TAG, "Cache cleared for date range: " + startDate + " to " + endDate);
    }

    // ==================== PRIVATE HELPER METHODS ====================

    /**
     * Pre-load team data for performance optimization.
     */
    private void preloadTeamData() {
        try {
            List<Team> teams = mTeamRepository.getAllTeams().join();
            for (Team team : teams) {
                mTeamCache.put(team.getId(), team);
            }
            Log.d(TAG, "Preloaded " + teams.size() + " teams");
        } catch (Exception e) {
            Log.w(TAG, "Error preloading team data", e);
        }
    }

    /**
     * Pre-load shift templates for performance optimization.
     */
    private void preloadShiftTemplates() {
        try {
            List<Shift> shiftTemplates = mShiftRepository.getAllShifts().join();
            for (Shift shift : shiftTemplates) {
                mShiftCache.put(shift.getId(), shift);
            }
            Log.d(TAG, "Preloaded " + shiftTemplates.size() + " shift templates");
        } catch (Exception e) {
            Log.w(TAG, "Error preloading shift templates", e);
        }
    }

    /**
     * Generate cache key for user schedule.
     */
    private String generateUserCacheKey(@NonNull Long userId, @NonNull LocalDate date) {
        return "user_" + userId + "_" + date.toString();
    }

    /**
     * Extract date from cache key for cache invalidation.
     */
    private String extractDateFromCacheKey(@NonNull String cacheKey) {
        // Extract date from cache key format: "user_123_2024-01-15"
        String[] parts = cacheKey.split("_");
        return parts.length >= 3 ? parts[2] : "";
    }

    /**
     * Create empty schedule day for dates with no assignments.
     */
    private WorkScheduleDay createEmptyScheduleDay(@NonNull LocalDate date) {
        return WorkScheduleDay.builder(date).build();
    }

    /**
     * Get user assignment for specific date.
     */
    @Nullable
    private UserScheduleAssignment getUserAssignmentForDate(@NonNull Long userId, @NonNull LocalDate date) {
        try {
            return mUserScheduleAssignmentRepository.getActiveAssignmentForUser(userId, date).join();
        } catch (Exception e) {
            Log.e(TAG, "Error getting user assignment for " + userId + " on " + date, e);
            return null;
        }
    }

    /**
     * Generate base schedule from assignment using domain engine.
     */
    private WorkScheduleDay generateBaseScheduleFromAssignment(@NonNull UserScheduleAssignment assignment,
                                                               @NonNull LocalDate date) {
        try {
            // Get recurrence rule from assignment (or create default if not available)
            RecurrenceRule recurrenceRule = getRecurrenceRuleFromAssignment(assignment);

            // Use RecurrenceCalculator domain engine to generate base schedule
            return mRecurrenceCalculator.generateScheduleForDate(date, recurrenceRule, assignment);
        } catch (Exception e) {
            Log.e(TAG, "Error generating base schedule from assignment", e);
            // Return empty schedule on error
            return WorkScheduleDay.builder(date).build();
        }
    }

    /**
     * Apply exceptions to schedule using domain algorithm.
     */
    private WorkScheduleDay applyExceptionsToSchedule(@NonNull WorkScheduleDay baseSchedule,
                                                      @NonNull Long userId, @NonNull LocalDate date) {
        try {
            // Get exceptions for this user and date
            List<ShiftException> exceptions =
                    mShiftExceptionRepository.getEffectiveExceptionsForUserOnDate(userId, date).join();

            if (exceptions.isEmpty()) {
                return baseSchedule;
            }

            // Build user-team mappings
            Map<Long, Team> userTeamMappings = buildUserTeamMappingsForPeriod(
                    List.of(userId), date, date);

            // Build replacement shifts map
            Map<String, WorkScheduleShift> replacementShifts = buildReplacementShiftsMap(exceptions);

            // Apply exceptions using pure domain algorithm
            return mExceptionResolver.applyExceptions(baseSchedule, exceptions,
                    userTeamMappings, replacementShifts);

        } catch (Exception e) {
            Log.e(TAG, "Error applying exceptions to schedule", e);
            return baseSchedule;
        }
    }

    /**
     * Build user-team mappings for the specified period.
     */
    private Map<Long, Team> buildUserTeamMappingsForPeriod(@NonNull List<Long> userIds,
                                                           @NonNull LocalDate startDate,
                                                           @NonNull LocalDate endDate) {
        Map<Long, Team> mappings = new HashMap<>();

        for (Long userId : userIds) {
            try {
                UserScheduleAssignment assignment =
                        mUserScheduleAssignmentRepository.getActiveAssignmentForUser(userId, startDate).join();
                if (assignment != null) {
                    Team team = mTeamRepository.getTeamById(assignment.getTeamId()).join();
                    if (team != null) {
                        mappings.put(userId, team);
                    }
                }
            } catch (Exception e) {
                Log.w(TAG, "Error building team mapping for user " + userId, e);
            }
        }

        return mappings;
    }

    /**
     * Build replacement shifts map from exceptions.
     */
    private Map<String, WorkScheduleShift> buildReplacementShiftsMap(@NonNull List<ShiftException> exceptions) {
        Map<String, WorkScheduleShift> replacements = new HashMap<>();

        for (ShiftException exception : exceptions) {
            if (exception.getNewShiftId() != null) {
                try {
                    Shift shift = mShiftRepository.getShiftById(exception.getNewShiftId()).join();
                    if (shift != null) {
                        // Convert Shift template to WorkScheduleShift instance
                        WorkScheduleShift workScheduleShift = createWorkScheduleShiftFromTemplate(shift);
                        replacements.put(exception.getNewShiftId(), workScheduleShift);
                    }
                } catch (Exception e) {
                    Log.w(TAG, "Error loading replacement shift: " + exception.getNewShiftId(), e);
                }
            }
        }

        return replacements;
    }

    /**
     * Find assignment for specific date from list.
     */
    @Nullable
    private UserScheduleAssignment findAssignmentForDate(@NonNull List<UserScheduleAssignment> assignments,
                                                         @NonNull LocalDate date) {
        return assignments.stream()
                .filter(assignment -> assignment.appliesTo(date))
                .findFirst()
                .orElse(null);
    }

    /**
     * Convert Shift template to WorkScheduleShift instance.
     */
    @NonNull
    private WorkScheduleShift createWorkScheduleShiftFromTemplate(@NonNull Shift shift) {
        return WorkScheduleShift.builder()
                .shift(shift)
                .startTime(shift.getStartTime())
                .endTime(shift.getEndTime())
                .localizer(mDomainLocalizer.scope("shifts"))
                .build();
    }

    /**
     * Get recurrence rule from assignment or create default.
     */
    @NonNull
    private RecurrenceRule getRecurrenceRuleFromAssignment(@NonNull UserScheduleAssignment assignment) {
        try {
            // Get recurrence rule ID from assignment
            String recurrenceRuleId = assignment.getRecurrenceRuleId();
            if (recurrenceRuleId != null && !recurrenceRuleId.trim().isEmpty()) {

                // Try to load RecurrenceRule from repository (would need RecurrenceRuleRepository)
                // For now, create rule based on ID pattern or use default
                RecurrenceRule rule = createRecurrenceRuleFromId(recurrenceRuleId);
                if (rule != null) {
                    return rule;
                }
            }

            // Create default QuattroDue cycle rule if not available
            return createDefaultQuattroDueRule();

        } catch (Exception e) {
            Log.w(TAG, "Error getting recurrence rule from assignment, using default", e);
            return createDefaultQuattroDueRule();
        }
    }

    /**
     * Create RecurrenceRule from ID (factory method based on naming convention).
     */
    @Nullable
    private RecurrenceRule createRecurrenceRuleFromId(@NonNull String ruleId) {
        try {
            // Parse rule type from ID (assuming naming convention like "quattrodue_cycle_18", "daily_shift", etc.)
            String[] parts = ruleId.toLowerCase().split("_");

            if (parts.length >= 2) {
                String frequencyType = parts[0];

                switch (frequencyType) {
                    case "quattrodue":
                    case "4-2":
                        return RecurrenceRule.builder()
                                .id(ruleId)
                                .frequency(RecurrenceRule.Frequency.QUATTRODUE_CYCLE)
                                .interval(1)
                                .cycleLength(18)
                                .localizer(mDomainLocalizer.scope("rules"))
                                .build();

                    case "daily":
                        return RecurrenceRule.builder()
                                .id(ruleId)
                                .frequency(RecurrenceRule.Frequency.DAILY)
                                .interval(1)
                                .cycleLength(1)
                                .localizer(mDomainLocalizer.scope("rules"))
                                .build();

                    case "weekly":
                        return RecurrenceRule.builder()
                                .id(ruleId)
                                .frequency(RecurrenceRule.Frequency.WEEKLY)
                                .interval(1)
                                .cycleLength(7)
                                .localizer(mDomainLocalizer.scope("rules"))
                                .build();

                    default:
                        Log.w(TAG, "Unknown frequency type in rule ID: " + frequencyType);
                        return null;
                }
            }

            Log.w(TAG, "Could not parse rule ID: " + ruleId);
            return null;

        } catch (Exception e) {
            Log.e(TAG, "Error creating RecurrenceRule from ID: " + ruleId, e);
            return null;
        }
    }

    /**
     * Create default QuattroDue recurrence rule.
     */
    @NonNull
    private RecurrenceRule createDefaultQuattroDueRule() {
        return RecurrenceRule.builder()
                .id("default_quattrodue_cycle")
                .frequency(RecurrenceRule.Frequency.QUATTRODUE_CYCLE)
                .interval(1)
                .cycleLength(18)
                .localizer(mDomainLocalizer.scope("rules"))
                .build();
    }

    /**
     * Filter exceptions for specific date.
     */
    private List<ShiftException> filterExceptionsForDate(@NonNull List<ShiftException> exceptions,
                                                         @NonNull LocalDate date) {
        return exceptions.stream()
                .filter(exception -> exception.appliesTo(date))
                .collect(Collectors.toList());
    }
}